Ofuscaci√≥n XOR para cargas √∫tiles (byte est√°tico)

Una de las formas m√°s sencillas de ocultar shellcode de los esc√°neres est√°ticos es XOR con una clave de un solo byte.

C√≥mo funciona:
Se trata de un OR exclusivo a nivel de bits aplicado a cada byte de una carga √∫til utilizando un byte clave fijo. El operador XOR (^) tiene una propiedad interesante:

A ^ B ^ B = A - esto significa que la codificaci√≥n y decodificaci√≥n utilizan exactamente la misma funci√≥n.
NOP (0x90) ^ 0xAA = 0x3A ‚Üí darle la vuelta con la misma clave ‚Üí 0x3A ^ 0xAA = 0x90

Pero aca est√° el truco:

Este m√©todo no escala bien. Una clave de un solo byte sobre una gran carga √∫til crea patrones.
Los analistas pueden forzar las 256 posibilidades de claves en milisegundos, un juego de ni√±os en el mundo de las ER.

Herramientas como CyberChef, xortool, o incluso un practicante de la facu avispado puede detectar y descifrar esto en segundos.

¬øCu√°ndo lo seguir√≠as usando?
Obfuscando fragmentos cortos de shellcode empaquetados en .rsrc o blobs de configuraci√≥n.
Evitar impactos de firmas est√°ticas en escaneos b√°sicos de AV o YARA
En stagers o loaders donde el tama√±o y el sigilo importan m√°s que la seguridad
Para decodificaci√≥n en memoria justo antes de VirtualAlloc + memcpy + ((void(*)())ptr)();

üí° TL;DR:
Single-byte XOR no va a salvar de REs o sandboxes, pero todav√≠a tiene su lugar en el conjunto de herramientas - especialmente cuando se encadena con capas de codificaci√≥n m√°s creativas, string hashing, o runtime injection
